Implement thread persistence in LangGraph.js using a checkpointer and a thread_id to pick up conversations exactly where they left off.

In LangGraph, conversation state is saved in "checkpoints" tied to a specific thread_id. To resume a conversation, you simply call the graph with the same thread_id in the configuration. While the official LangGraph.js documentation currently highlights SqliteSaver and PostgresSaver for persistent storage, the pattern for using a checkpointer remains the same regardless of the backend.

import { StateGraph, START, END, MemorySaver } from "@langchain/langgraph";
import { Annotation } from "@langchain/langgraph";

// 1. Define your state
const GraphState = Annotation.Root({
  messages: Annotation<any[]>({
    reducer: (x, y) => x.concat(y),
  }),
});

// 2. Initialize your checkpointer
// Note: For production with Redis, you can implement a custom BaseCheckpointSaver 
// or use the built-in Postgres/SQLite savers.
const checkpointer = new MemorySaver();

// 3. Compile the graph with the checkpointer
const app = new StateGraph(GraphState)
  .addNode("agent", async (state) => {
    // Your logic here
    return { messages: [{ role: "assistant", content: "Hello!" }] };
  })
  .addEdge(START, "agent")
  .addEdge("agent", END)
  .compile({ checkpointer });

// 4. Use thread_id to persist and retrieve state
const config = { configurable: { thread_id: "user-123" } };

// First call saves state to "user-123"
await app.invoke({ messages: [{ role: "user", content: "Hi!" }] }, config);

// Second call with same thread_id retrieves previous messages automatically
await app.invoke({ messages: [{ role: "user", content: "How are you?" }] }, config);
Copy
Resuming with Redis
To use Redis specifically for LangGraph threads in TypeScript, you would typically use a checkpointer implementation compatible with Redis. If an official @langchain/langgraph-checkpoint-redis is not yet available for your environment, you can use the PostgresSaver for high-performance production persistence or implement a custom checkpointer by extending the BaseCheckpointSaver class.

For simpler, non-graph based chat history, you can use the RedisChatMessageHistory from the @langchain/redis package:

import { RedisChatMessageHistory } from "@langchain/redis";

const history = new RedisChatMessageHistory({
  sessionId: "user-123",
  url: "redis://localhost:6379",
});

// Add and retrieve messages
await history.addMessage({ role: "user", content: "Hi" });
const messages = await history.getMessages();
Copy
The thread_id acts as the primary key for the conversation state, allowing the graph to load the full message history and intermediate step results before processing the new input.

Relevant docs:

Persistence in LangGraph.js
Memory Management Guide
How to get thread state