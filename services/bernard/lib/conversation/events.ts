/**
 * Conversation Event Types
 * 
 * Defines all event types used for conversation recording in Bernard.
 * Events are recorded chronologically as they occur during conversation processing.
 */

/**
 * Tool call data structure (simplified from LangChain)
 */
export interface ToolCallData {
  id: string;
  type: string;
  function?: {
    name?: string;
    arguments?: string;
  };
  [key: string]: unknown;
}

/**
 * Base event structure shared by all conversation events
 */
export interface BaseEvent {
  /** Unique event ID (auto-generated by the recorder) */
  id: string;
  /** Event type discriminator */
  type: string;
  /** ISO 8601 timestamp when event occurred */
  timestamp: string;
  /** Event-specific data payload */
  data: Record<string, unknown>;
}

/**
 * Event type for user messages
 */
export interface UserMessageEvent extends BaseEvent {
  type: "user_message";
  data: {
    /** Unique message ID */
    messageId: string;
    /** User's message content */
    content: string;
    /** Optional token count */
    tokenCount?: number;
  };
}

/**
 * Event type for LLM calls (router or response model)
 */
export interface LLMCallEvent extends BaseEvent {
  type: "llm_call";
  data: {
    /** ID of the message being responded to */
    messageId: string;
    /** Which agent stage invoked the LLM */
    stage: "router" | "response";
    /** Model name (e.g., "claude-3-5-sonnet") */
    model: string;
    /** Full message context sent to LLM */
    context: unknown;
    /** Tools available to LLM */
    availableTools: unknown;
    /** Optional request ID for tracing */
    requestId?: string;
    /** Optional turn ID */
    turnId?: string;
  };
}

/**
 * Event type for LLM responses
 */
export interface LLMResponseEvent extends BaseEvent {
  type: "llm_response";
  data: {
    /** ID of the message being responded to */
    messageId: string;
    /** Which agent stage responded */
    stage: "router" | "response";
    /** LLM's text response (empty if tool calls) */
    content: string;
    /** Time spent in LLM call (milliseconds) */
    executionDurationMs: number;
    /** Token usage */
    tokens?: {
      /** Prompt tokens */
      in: number;
      /** Completion tokens */
      out: number;
    };
    /** Stop reason from API */
    finishReason?: string;
    /** Any tool calls made by LLM */
    toolCalls?: ToolCallData[];
  };
}

/**
 * Event type for tool invocations
 */
export interface ToolCallEvent extends BaseEvent {
  type: "tool_call";
  data: {
    /** Tool call ID (from LLM's tool_calls) */
    toolCallId: string;
    /** Tool name (e.g., "web_search") */
    toolName: string;
    /** ID of the AI message that triggered this */
    messageId?: string;
    /** JSON string of tool arguments */
    arguments: string;
  };
}

/**
 * Event type for tool execution results
 */
export interface ToolResponseEvent extends BaseEvent {
  type: "tool_response";
  data: {
    /** Must match corresponding tool_call */
    toolCallId: string;
    /** Tool name */
    toolName: string;
    /** Tool execution result */
    result: string;
    /** Time spent in tool execution (milliseconds) */
    executionDurationMs: number;
    /** Error message if tool failed */
    error?: string;
  };
}

/**
 * Event type for final assistant messages
 */
export interface AssistantMessageEvent extends BaseEvent {
  type: "assistant_message";
  data: {
    /** Unique message ID */
    messageId: string;
    /** Final assistant response content */
    content: string;
    /** Total time for this turn (milliseconds) */
    totalDurationMs: number;
    /** Total tools invoked this turn */
    totalToolCalls: number;
    /** Total LLM invocations this turn */
    totalLLMCalls: number;
  };
}

/**
 * Union type of all conversation event types
 */
export type ConversationEvent =
  | UserMessageEvent
  | LLMCallEvent
  | LLMResponseEvent
  | ToolCallEvent
  | ToolResponseEvent
  | AssistantMessageEvent;

/**
 * Type guard to check if an event is a specific type
 */
export function isEventType<T extends ConversationEvent>(
  event: ConversationEvent,
  type: T["type"]
): event is T {
  return event.type === type;
}

/**
 * Event type constants for discriminated unions
 */
export const EVENT_TYPES = {
  USER_MESSAGE: "user_message" as const,
  LLM_CALL: "llm_call" as const,
  LLM_RESPONSE: "llm_response" as const,
  TOOL_CALL: "tool_call" as const,
  TOOL_RESPONSE: "tool_response" as const,
  ASSISTANT_MESSAGE: "assistant_message" as const,
} as const;

/**
 * Helper to create a base event with auto-generated ID and timestamp
 */
export function createBaseEvent(
  type: string,
  data: Record<string, unknown>
): BaseEvent {
  return {
    id: `evt_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
    type,
    timestamp: new Date().toISOString(),
    data,
  };
}
