import type { BaseMessage } from "@langchain/core/messages";
import type { AgentOutputItem } from "../../streaming/types";
import type { LLMCaller } from "../../llm/llm";
import { buildResponseSystemPrompt } from "./prompts";
import { RecordKeeper } from "@/lib/conversation";

/**
 * Context passed to the response harness
 */
export type ResponseHarnessContext = {
  conversationId: string;
  messages: BaseMessage[];
  llmCaller: LLMCaller;
  abortSignal?: AbortSignal;
  recordKeeper: RecordKeeper;
};

/**
 * Response harness that generates streaming text responses.
 * Yields delta events for each token as they are generated by the LLM.
 */
export async function* runResponseHarness(context: ResponseHarnessContext): AsyncGenerator<AgentOutputItem> {
  const { messages, llmCaller, abortSignal, recordKeeper, conversationId } = context;

  // Build system prompt
  const systemPrompt = buildResponseSystemPrompt();

  // Create prompt context for the LLM
  // Filter out any existing system messages from the conversation history
  const promptMessages: BaseMessage[] = [
    {
      type: "system",
      content: systemPrompt,
    } as any,
    ...messages.filter(msg => msg.type !== "system"),
  ];

  // Stream tokens from the LLM
  let finishReason: "stop" | "length" | "content_filter" | undefined;

  try {
    let responseContent = "";
    for await (const token of llmCaller.streamText(promptMessages, {
      model: "response-generator",
      temperature: 0.7, // Creative but consistent responses
      maxTokens: 1000,
      ...(abortSignal ? { abortSignal } : {}),
    })) {
      yield {
        type: "delta",
        content: token,
      };
      responseContent += token;
    }

    finishReason = "stop";
    await recordKeeper.appendMessages(conversationId, [
      {
        type: "assistant",
        content: responseContent,
      } as any,
    ]);
  } catch (error) {
    // Handle abort or other errors
    if (error instanceof Error && error.name === "AbortError") {
      finishReason = "stop"; // Treat abort as normal completion
    } else {
      console.error("Error in response harness:", error);
      // Yield error event so it can be handled upstream
      yield {
        type: "error",
        error: error instanceof Error ? error.message : String(error),
      };
      finishReason = "stop"; // Still yield a finish event
    }
  }

  // Yield final delta with finish_reason
  if (finishReason) {
    yield {
      type: "delta",
      content: "",
      finishReason,
    };
  }
}
